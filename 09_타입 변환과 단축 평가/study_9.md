# 📕 9장 타입 변환과 단축 평가

## 📝 9.1 타입 변환이란?

JS의 모든 값에는 타입이 있고 이는 개발자의 의도에 따라 변경이 가능하다.

- 원시 값의 타입은 변하지 않고 변경된 타입의 새로운 값을 생성한다.

#### 💡 명시적 타입 변환 or 타입 캐스팅

개발자가 의도적으로 값의 타입을 변경하는 것.

- 값의 타입을 예측할 수 있다.

#### 💡 암묵적 타입 변환 or 타입 강제 변환

개발자의 의도와 상관없이 표현식을 평가하는 과정에서 JS 엔진에 의해 암묵적으로 타입이 변환되는 것.

- 변경된 타입이 재할당 되지 않는다.
- 표현식을 에러 없이 평가하기 위해 암묵적 타입 변환해 새로운 값을 만들어 한 번 사용하고 버린다.
- 암묵적 타입 변환이 발생한다면 어떤 타입으로 변환되는지, 변환된 값이 어떻게 평가되는지 예측할 수 있어야 한다.
- 타입 변환의 결과를 예측하지 못하면 오류를 생산할 수 있다.
- 타입 변환의 결과를 예측할 수 있다면 명시적 타입 변환보다 암묵적 타입 변환이 가독성 측면에서 더 좋을 수 있다.

## 📝 9.2 암묵적 타입 변환

JS 엔진은 표현식을 평가할 때 가급적 에러가 발생하지 않도록 코드의 문맥에 맞게 암묵적 타입 변환해 표현식을 평가한다. 변환된 타입은 원시 타입 중 하나다.

### ✏️ 9.2.1 문자열 타입으로 변환

- 문자열 연결 연산자의 목적은 문자열 값을 만드는 것이기 때문에 모든 피연산자는 문자열 타입이어야 한다.
- 문자열 연결 연산자를 사용해 피연산자 중 문자열이 아닌 값을 문자열 타입으로 변환한다.
- 템플릿 리터럴의 경우 피연산자가 아닌 평가결과 자체를 문자열로 변환한다.

```js
0 + ""; // "0"
NaN + ""; // "NaN"

// 불리언, null, undefined 타입
true + ""; // "true"
null + ""; // "null"
undefined + ""; // "undefined"

// 심볼 타입
Symbol() + ""; // TypeError

// 객체 타입
({}) + ""; // "[object Object];
[] + ""; // ""
[10, 10] + ""; // "10,10"
function(){} + ""; // "function(){}"
```

### ✏️ 9.2.2 숫자 타입으로 변환

- 산술 연산자의 목적은 숫자 값을 만드는 것이기 때문에 모든 피연산자는 숫자 타입이어야 한다.
- 숫자 타입으로 변환할 수 없는 피연산자가 있으면 평가 결과가 `NaN`이 된다.
- 비교 연산자는 값의 크기를 비교한다 따라서 피연산자의 타입이 숫자 타입이어야 한다.
- `+`단항 연산자는 피연산자가 숫자 타입이 아닌 경우 숫자 타입의 값으로 암묵적 타입 변환한다.

```js
1 - "1"; // 0
1 * "10"; // 10
1 / "string"; // NaN

"1" < 10; // true

+""; // 0
+"string"; // NaN
+"10"; // 10

+true; // 1
+false; // 0
+null; // 0
+undefined; // NaN
+Symbol(); // TypeError
+{}; // NaN
+[]; // 0
+function () {}; // NaN
```

### ✏️ 9.2.3 불리언 타입으로 변환

`if` 문이나 `for` 문과 같은 제어문의 조건식은 불리언 값으로 평가되어야 한다. JS 엔진은 조건식의 평가 결과를 암묵적 타입 변환한다.

- JS 엔진은 불리언 타입이 아닌 값을 Truthy 값, Falsy 값으로 구분한다.
- 불리언 값으로 평가되어야 하는 문맥에서 Truthy 값은 `true`로, Falsy 값은 `false`로 타입 변환된다.
- Falsy 값: `false`, `undefined`, `null`, 0, -0, `NaN`, ""
- Truthy 값: Falsy 값 외 모든 값

```js
if(truthy) {
  코드 블록 실행
}

if(falsy) {
  코드 블록 미실행
}
```
