# 📕 15장 let, const 키워드와 블록 레벨 스코프

## 📝 15.1 var 키워드로 선언한 변수의 문제점

### ✏️ 15.1.1 변수 증복 선언 허용

`var` 키워드로 선언한 변수는 중복 선언을 허용하고 초기화문의 유무에 따라 다르게 동작한다.

- 초기화문이 있으면 `var` 키워드가 없는 것처럼 동작한다.
- 초기화문이 없으면 무시된다.(에러가 발생하지 않는다)

변수의 중복 선언이 허용되면서 값까지 할당한다면 의도치 않게 먼전 선언되 변수의 값이 바뀔 수 있다.

```js
var x = 1;
var y = 1;

var x = 100; // var 키워드가 없는 것처럼 동작
var y; // 무시

console.log(x); // 100
console.log(y); // 1
```

### ✏️ 15.1.2 함수 레벨 스코프

- var 키워드는 함수 레벨 스코프를 지원하기 때문에 함수 외부에 선언된 변수는 모두 전역 변수다.
- 함수 레벨 스코프는 전역 변수를 남발할 가능성이 높아 변수가 중복될 가능성이 높아진다.

```js
var x = 10;

for (var x = 1; x < 5; x++) {
  console.log(x); // 1 2 3 4
}

console.log(x); // 5

if (true) {
  var x = 20;
}

console.log(x); // 20
```

### ✏️ 15.1.3 변수 호이스팅

`var` 키워드로 선언한 변수는 변수 호이스팅에 의해 선언문이 스코프의 선두로 끌어올려진 것처럼 동작한다.

- 호이스팅에 의해 선언문 이전에 참조할 수 있지만 `undefined`를 반환한다.
- 선언문 이전에 변수를 참조하면 에러는 발생하지 않지만 프로그램의 흐름상 맞지 않고 코드의 가독성이 떨어져 오류를 발생시킬 수 있다.

## 📝 15.2 let 키워드

### ✏️ 15.2.1 변수 중복 선언 금지

let 키워드로 변수를 중복 선언하면 `Syntax` 에러가 발생한다.

### ✏️ 15.2.2 블록 레벨 스코프

`let` 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

- 함수, `if`, `for`, `while`, `try/catch` 등...
- 블록 스코프 외부에서 변수를 참조할 수 없다.
- 함수 내부에 선언된 코드 블록은 함수 레벨 스코프에 중첩된다.

```js
let foo = 100; // 전역

{
  let foo = 20; // 지역
  let bar = 10; // 지역
}

console.log(foo); // 100 -> 전역 foo
console.log(bar); // ReferenceError
```

### ✏️ 15.2.3 변수 호이스팅

`let` 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

- `var` 키워드와 달리 변수 '선언 단계'와 '초기화 단계'가 분리되어 진행된다. -> 선언문 이전에 참조 불가능
- 초기화 단계는 런타임 시점 변수 선언문에 도달했을 때 실행된다.
- 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 **사각지대**라고 한다.

```js
console.log(foo); // ReferenceError foo is not defined

let foo;

console.log(foo); // undefined

foo = 1;

console.log(foo); // 1
```

```js
let foo = 1;

{
  console.log(foo); // ReferenceError 만약 변수 호이스팅이 발생하지 않는다면 전역 변수foo를 불러와야 한다.

  let foo = 2;
}
```

JS는 ES6에서 도입된 `let`, `const` 포함 모든 선언을 호이스티한다. 하지만 `let`, `const`, `class`를 사용한 선언문은 호이스팅이 발생하지 않은 것처럼 동작한다.

### ✏️ 15.2.4 전역 객체와 let

- `let` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니기 때문에 `window.변수`와 같이 접근할 수 없다.
- `let` 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환결 레코드) 내에 존재한다.

## 📝 15.3 const 키워드

상수를 선언하기 위해 사용하지만 반드시 상수만을 위해 사용하지는 않는다. 특직이 `let` 키워드와 대부분 동일하다.

### ✏️ 15.3.1 선언과 초기화

- `const` 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.
- 블록 레벨 스코프를 지원한다.
- 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

```js
const foo = 1;

const foo; // SyntaxError
```

### ✏️ 15.3.2 재할당 금지

`const` 키워드로 선언한 변수는 재할당이 금지된다.

```js
const foo = 1;

foo = 2; // TypeError
```

### ✏️ 15.3.3 상수

`const` 키워드로 선언한 변수에 원시 값을 할당하면 해당 값은 변경할 수 없다. 이러한 특징을 이용해 상수를 표현하는데 사용하기도 한다.

- 상수는 재할당이 금지된 변수다.
- `const` 의 재할당 금지 + 원시 값의 변경 불가능한 값 => 할당된 값을 변경할 수 있는 방법이 없다.
- 상태 유지, 가독성, 유지보수의 편의를 위해 적극적으로 사용하자.
- 코드 내에서 쉽게 변경되지 않는 값, 고정된 값을 표현할 때 사용하면 해당 값이 어떤 의미인지 명확하게 표현이 가능하고 추후 값을 변경할 때 상수의 값만 수정하면 된다.
- 상수의 이름은 대문자로 선언하고, 여러 단어로 이루어진 경우 스네이크 케이스로 표현한다.

```js
const MONDAY = '월요일';
const WEEK_COUNT = 7;

for (let i = 0; i < WEEK_COUNT; i++) {
  if (i === 1) {
    console.log(MONDAY); // 월요일
  }
}
```

### ✏️ 15.3.4 const 키워드와 객체

`const` 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다. -> 변경 가능한 값은 재할당 없이도 값을 변경할 수 있기 때문이다.

- `const` 는 재할당을 금지할 뿐 불변을 의미하지 않는다.
- 재할당은 금지되지만 프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체를 변경 가능하다. -> 객체가 변경되도 참조 값은 변경되지 않는다.

## 📝 15.4 var vs. let vs. const

변수는 기본적으로 const로 선언하고 재할당이 필요한 경우 let을 사용하는 것이 좋다. -> const 선언은 재할당을 방지하기 때문에 좀 더 안전하다.

- ES6를 사용한다면 var를 사용하지 않는다.
- 재할당이 필요한 경우에 한정해 let을 사용한다. (스코프를 최대한 좁게 사용)
- 변경이 발생하지 않고 읽기 전용으로 사용하는 원시 값과, 객체에는 const를 사용한다.
