# 📢 25장 클래스 25.1~25.5 발표발표

## 📝 클래스는 프로토타입의 문법적 설탕인가?

자바스크립트는 프로토타입 기반 객체지향 언어로 클래스 없이 생성자 함수와 프로토타입을 통해 상속을 구현할 수 있다.

```js
// 예시
var Person = (function () {
  function Person(name) {
    this.name = name;
  }

  Person.prototype.sayHi = function () {
    console.log(this.name);
  };

  return Person;
})();

var me = new Person('OH');
me.sayHi(); // OH
```

ES6에서 도입된 클래스는 기존 클래스 기반 언어를 사용하던 프로그래머들이 더 빠르게 학습할 수 있도록 클래스 기반 언어와 흡사한 새로운 객체 생성 메커니즘을 제시한다.

클래스는 사실 함수이며 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 **문법적 설탕**이라고 볼 수 있다.

### 💡 클래스와 생성자 함수의 차이

클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 동일하게 동작하지는 않는다. 클래스는 보다 엄격하며 생성자 함수에서 제공하지 않는 기능도 제공한다.

#### ✅ 클래스

- new 연산자 없이 호출하면 에러가 발생한다.
- 호이스팅이 발생하지 않는 것처럼 동작한다.
- 내부의 모든 코드에 암묵적으로 strict mode가 지정되며 해제할 수 없다.
- constructor, 프로토타입 메서드, 정적 메서드 모두 [[Enumerable]] 값이 false라서 열거할 수 없다.
- 상속을 지원하는 extends, super 키워드를 제공한다.

#### ✅ 생성자 함수

- new 연산자 없이 호출하면 일반 함수로서 동작한다.
- 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.
- 암묵적으로 strict mode가 지정되지 않는다.

위와 같은 차이점을 보면 클래스를 단순한 문법적 설탕으로 보기보다는 **새로운 객체 생성 메커니즘**으로 보는 것이 합당해 보인다.

## 📝 클래스 정의

class 키워드를 사용해 정의하며 이름은 파스칼케이스로 사용하는 것이 일반적이다. 하지만 파스칼케이스를 사용하지 않아도 에러는 발생하지 않는다.

```js
class Person {}
```

기명 또는 익명으로 표현식을 사용해 정의할 수 있다. 표현식으로 정의할 수 있다는 것은 클래스가 일급 객체라는 것을 의미한다.

```js
// 익명
const Person = class {};

// 기명
const Person = class ClassName {};
```

### 💡 클래스가 일급 객체로서 갖는 특징

- 무명의 리터럴로 생성할 수 있다. (런타임에 생성 가능)
- 변수 or 자료구조에 저장할 수 있다.
- 함수의 매개변수에게 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.

### 💡 클래스 정의 방식

클래스는 0개 이상의 메서드(**constructor, 프로토타입 메서드, 정적 메서드**)만 정의할 수 있다.

```js
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(this.name);
  }

  // 정적 메서드
  strict sayHello() {
    console.log('hello');
  }
}

const me = new Person('OH');

// 프로토타입 메서드 호출
me.sayHi(); // OH

// 정적 메서드 호출
Person.sayHello(); // hello
```

#### ✅ 생성자 함수와 비교

클래스와 생성자 함수의 정의 방식은 형태적인 면에서 매우 유사하다.

<img src='./public/생성자 함수, 클래스 정의 방식 비교 복사본.jpeg'>

## 📝 클래스 호이스팅

- 함수 선언문처럼 런타임 이전에 먼저 평가되어 함수 객체(**constructor**)와 프로토타입을 생성한다. 프로토타입과 생성자 함수는 언제나 쌍으로 존재한다.
- 정의 이전에 참조할 수 없다.
- let, const 키워드처럼 호이스팅이 되며 일지적 사각지대에 빠져 호이스팅이 발생하지 않는 것처럼 동작한다.

## 📝 인스턴스 생성

클래스는 인스턴스를 생성하는 것이 유일한 존재 이유이기 때문에 반드시 new 연산자와 함께 호출해야 한다.

클래스 표현식으로 정의한 경우 클래스를 가리키는 식별자를 사용해 인스턴스를 생성해야 한다. 만약 클래스 이름으로 인스턴스를 생성하면 에러가 발생한다.(클래스 이름은 외부에서 접근 불가능)

```js
const Person = class ClassName {};

const me = new ClassName(); // ReferenceError: ClassName is not defined
```

## 📝 메서드

### 💡constructor

인스턴스를 생성하고 초기화하기 위한 특수한 메서드로 이름을 변경할 수 없다.

#### ✅ 클래스 내부

<img src='./public/클래스 내부 복사본.jpeg'>

클래스는 평가되어 함수 객체가 되고 프로토타입과 연결되어 있어 자신의 스코프 체인을 구성한다.

프로토타입 객체의 constructor 프로퍼티가 클래스 자신을 가리키고 있는데 이는 클래스가 인스턴스를 생성하는 생성자 함수라는 것을 의미한다.

#### ✅ 인스턴스 내부

<img src='./public/인스턴스 내부 복사본.jpeg'>

constructor 내부의 this는 클래스가 생성한 인스턴스를 가리키기 때문에 constructor 내부에서 this에 추가한 프로퍼티는 인스턴스 프로퍼티가 된다.

클래스 내부나 인스턴스 내부 어디에도 constructor 메서드가 보이지 않는데 그 이유는 constructor는 단순한 메서드가 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 되기 때문이다. 즉 클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성된다.

클래스의 constructor 메서드와 프로토타입의 constructor 프로퍼티는 같은 메서드처럼 보이지만 직접적인 관련이 없고, 프로토타입의 constructor는 모든 프로토타입이 가지고 있으며 생성자 함수를 가리킨다.

#### ✅ 클래스 constructor의 특징

- 클래스 내부에 한 개만 존재할 수 있다.
- 생략할 수 있다.
  - 빈 constructor가 암묵적으로 생성되 빈 객체를 반환한다.
  - 인스턴스를 초기화 하려면 constructor를 생략하면 안된다.
- 암묵적으로 this(인스턴스)를 반환하기 때문에 반환문을 가지면 안된다.
  - 별도의 반환문으로 객체를 반환하면 this가 반환되지 않는다.
  - 원시값을 반환하면 무시되고 this가 반환된다.

### 💡 프로토타입 메서드

클래스에서는 생성자 함수와 다르게 별도의 과정 없이 프로토타입 메서드를 추가할 수 있으며, 생성자 함수와 똑같이 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다.

```js
class Person {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    console.log(this.name);
  }
}

const me = new Person('OH');

// me 객체의 프로토타입은 Person.prototype
Object.getPrototypeOf(me) === Person.prototype; // true
me instanceof Person; // true

// Person.prototype의 프로토타입은 Object.prototype
Object.getPrototypeOf(Person.prototype) === Object.prototype; // true
me instanceof Object; // true

// me 객체의 constructor는 Person
me.constructor === Person; // true
```

<img src='./public/클래스로 생성한 인스턴스의 프로토타입 체인 복사본.jpeg'>

클래스 내부에서 정의한 메서드는 인스턴스의 프로토타입에 있는 메서드가 되며 인스턴스는 프로토타입 메서드를 상속받아 사용할 수 있다. 따라서 클래스는 생성자 함수처럼 프로토타입 기반의 객체 생성 메커니즘이다.

### 💡 정적 메서드

정적 메서드는 인스턴스를 생성하지 않아도 사용할 수 있는 메서드이며 클래스에서는 static 키워드를 사용해 정의할 수 있다.

```js
class Person {
  constructor(name) {
    this.name = name;
  }

  static sayHi() {
    console.log('HI');
  }
}
```

<img src='./public/정적 메서드.jpeg'>

위 사진처럼 정적 메서드는 클래스에 바인딩되고. 클래스는 함수 객체로 평가되 자신의 프로퍼티/메서드를 소유할 수 있다.

클래스가 정의되는 시점에 함수 객체가 되므로 인스턴스와 다르게 별도의 생성 과정 없이 정적 메서드를 호출할 수 있고, 정적 메서드는 인스턴스가 아닌 클래스로 호출해야 한다.(인스턴스의 프로토타입 체인 상에 클래스가 존재하지 않기 때문)

### 💡 정적 메서드와 프로토타입 메서드의 차이

- 정적 메서드와 프로토타입 메서드는 속해 있는 프로토타입 체인이 다르다.
- 정적 메서드는 클래스를 호출하고 프로토타입 메서드는 인스턴스를 호출한다.
- 정적 메서드는 인스턴스 프로포티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.

정적 메서드는 인스턴스 프로퍼티를 참조할 수 없기 때문에 인스턴스 프로퍼티를 참조해야 하는 경우 프로토타입 메서드를 사용해야 한다. 하지만 this를 사용하지 않는 경우 별도의 인스턴스를 생성하지 않아도 되는 정적 메서드를 사용하는 것이 좋다.

클래스의 장점으로는 하나의 네임스페이스로 정적 메서드를 모아 이름 충돌 가능성을 줄여 주고 관련 함수들을 구조화할 수 있다. 정적 메서드는 앱 전역에서 사용할 유틸리티 함수를 메서드로 구조화할 때 유용하다.

### 💡 클래스에서 정의한 메서드의 특징

- function 키워드를 생략한 축약 표현을 사용한다.
- 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요없다.
- 암묵적으로 strict mode로 실행된다.
- for...in, Object.keys 메서드 등으로 열거할 수 없다.
- 내부 메서드 [[Constructor]]를 갖지 않는 non-constructor다. -> new 연산자와 함께 호출할 수 없다.
